---
import { SITE } from "@/config";
import "@/styles/global.css";
import { ClientRouter } from "astro:transitions";

export interface Props {
  title?: string;
  author?: string;
  profile?: string;
  description?: string;
  ogImage?: string;
  canonicalURL?: string;
  pubDatetime?: Date;
  modDatetime?: Date | null;
  scrollSmooth?: boolean;
  robots?: string;
  prevPost?: { slug: string; title?: string } | null;
  nextPost?: { slug: string; title?: string } | null;
}

const {
  title = SITE.title,
  author = SITE.author,
  profile = SITE.profile,
  description = SITE.desc,
  ogImage = SITE.ogImage,
  canonicalURL = new URL(Astro.url.pathname, Astro.url),
  pubDatetime,
  modDatetime,
  scrollSmooth = false,
  robots = "index, follow",
} = Astro.props;
const socialImageURL = new URL(ogImage ?? SITE.ogImage ?? "og.png", Astro.url);

// Ensure date values are Date objects before calling toISOString()
const pubDateObj = pubDatetime
  ? pubDatetime instanceof Date
    ? pubDatetime
    : new Date(pubDatetime)
  : undefined;
const modDateObj = modDatetime
  ? modDatetime instanceof Date
    ? modDatetime
    : new Date(modDatetime)
  : undefined;

const structuredData = {
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  headline: `${title}`,
  image: `${socialImageURL}`,
  ...(pubDateObj && { datePublished: pubDateObj.toISOString() }),
  ...(modDateObj && { dateModified: modDateObj.toISOString() }),
  author: [
    {
      "@type": "Person",
      name: `${author}`,
      ...(profile && { url: profile }),
    },
  ],
};
---

<!doctype html>
<html lang="th" class={`${scrollSmooth && "scroll-smooth"}`}>
  <head>
    {/* Prev/Next links for articles (set by page via layout props) */}
    {
      Astro.props.prevPost && (
        <link rel="prev" href={`/blog/${Astro.props.prevPost.slug}`} />
      )
    }
    {
      Astro.props.nextPost && (
        <link rel="next" href={`/blog/${Astro.props.nextPost.slug}`} />
      )
    }
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="canonical" href={canonicalURL} />
    <meta name="generator" content={Astro.generator} />

    <!-- Google Tag Manager -->
    <script is:inline>
      (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });
        var f = d.getElementsByTagName(s)[0],
          j = d.createElement(s),
          dl = l != "dataLayer" ? "&l=" + l : "";
        j.async = true;
        j.src = "https://www.googletagmanager.com/gtm.js?id=" + i + dl;
        f.parentNode.insertBefore(j, f);
      })(window, document, "script", "dataLayer", "GTM-KP5D5J3");
    </script>
    <!-- End Google Tag Manager -->

    <!-- General Meta Tags -->
    <title>{title}</title>
    <meta name="title" content={title} />
    <meta name="description" content={description} />
    <meta name="author" content={author} />
    <meta
      name="keywords"
      content="front-end development, React, JavaScript, HTML, CSS, ภาษาไทย, บล็อก, tutorial, web development"
    />
    <meta name="robots" content={robots} />
    <link rel="sitemap" href="/sitemap-index.xml" />

    <!-- Open Graph / Facebook -->
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonicalURL} />
    <meta property="og:image" content={socialImageURL} />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content={SITE.title} />
    <meta property="og:locale" content="th_TH" />

    <!-- Article Published/Modified time -->
    {
      pubDateObj && (
        <meta
          property="article:published_time"
          content={pubDateObj.toISOString()}
        />
      )
    }
    {
      modDateObj && (
        <meta
          property="article:modified_time"
          content={modDateObj.toISOString()}
        />
      )
    }

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content={canonicalURL} />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    <meta property="twitter:image" content={socialImageURL} />

    <!-- Google JSON-LD Structured data -->
    <script
      is:inline
      type="application/ld+json"
      set:html={JSON.stringify(structuredData)}
    />

    <!-- Organization Schema -->
    <script
      is:inline
      type="application/ld+json"
      set:html={JSON.stringify({
        "@context": "https://schema.org",
        "@type": "Organization",
        name: SITE.title,
        url: SITE.website,
        logo: `${SITE.website}${SITE.ogImage}`,
        description: SITE.desc,
      })}
    />

    <!-- Load Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      rel="preload"
      href="https://fonts.gstatic.com/s/ibmplexmono/v19/-F6pfjptAgt5VM-kVkqdyU8n3kwq0nJN2qk_-k.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,500;0,600;0,700;1,400;1,600&display=swap"
      rel="stylesheet"
    />

    <meta name="theme-color" content="#ffffff" />
    <meta name="color-scheme" content="light dark" />

    <!-- Cookie -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/orestbida/cookieconsent@v2.8.6/dist/cookieconsent.css"
    />

    <!-- Waline comment style -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/@waline/client@v3/dist/waline.css"
    />
    <!-- Waline comment end -->

    <!-- Web Vitals Monitoring -->
    <script is:inline>
      // Load web-vitals library
      (function () {
        const script = document.createElement("script");
        script.src = "https://unpkg.com/web-vitals@3/dist/web-vitals.iife.js";
        script.onload = function () {
          // web-vitals is now available as window.webVitals
          function sendToAnalytics({ name, delta, value, id }) {
            // Push to dataLayer (GTM) if available
            if (
              window.dataLayer &&
              typeof window.dataLayer.push === "function"
            ) {
              window.dataLayer.push({
                event: "web-vitals",
                event_category: "Web Vitals",
                event_action: name,
                event_label: id,
                value: Math.round(name === "CLS" ? delta * 1000 : delta),
                metric_value: value,
              });
            }

            // Also log to console for debugging
            console.log(`${name}:`, {
              delta: Math.round(delta),
              value: Math.round(value),
              id,
            });
          }
          // Track Core Web Vitals
          if (window.webVitals) {
            window.webVitals.getCLS(sendToAnalytics);
            window.webVitals.getFID(sendToAnalytics);
            window.webVitals.getFCP(sendToAnalytics);
            window.webVitals.getLCP(sendToAnalytics);
            window.webVitals.getTTFB(sendToAnalytics);
          }
        };
        document.head.appendChild(script);
      })();
    </script>

    <ClientRouter />

    <script is:inline src="/toggle-theme.js"></script>
  </head>
  <body class="pt-[8vh] md:pt-[12vh]">
    <!-- Google Tag Manager (noscript) -->
    <noscript
      ><iframe
        src="https://www.googletagmanager.com/ns.html?id=GTM-KP5D5J3"
        height="0"
        width="0"
        style="display:none;visibility:hidden"></iframe>
    </noscript>
    <!-- End Google Tag Manager (noscript) -->

    <slot />

    <!-- Cookie -->
    <script
      is:inline
      src="https://cdn.jsdelivr.net/gh/orestbida/cookieconsent@v2.8.6/dist/cookieconsent.js"
    ></script>
    <script
      is:inline
      src="https://cdn.jsdelivr.net/gh/pickyzz/blog-rebuild@main/public/cookies.js"
    ></script>

  <!-- Code copy button script -->
  <script is:inline type="module" src="/scripts/code-copy.js"></script>

    <!-- TOC Script -->
    <script is:inline>
      // TOC Highlight and Click Handling
      let debounceTimer = null;
      let rafId = null;

      // Debounce function to prevent rapid firing
      function debounce(func, wait) {
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(debounceTimer);
            func(...args);
          };
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(later, wait);
        };
      }

      // Function to update active TOC link
      const updateActiveTocLink = debounce(() => {
        const headings = Array.from(
          document.querySelectorAll(
            ".notion-content h1[id], .notion-content h2[id], .notion-content h3[id], .notion-content h4[id], .notion-content h5[id], .notion-content h6[id]"
          )
        );

        // Find the heading at the top of the viewport
        let topHeading = null;
        let minTop = Infinity;

        headings.forEach(heading => {
          const rect = heading.getBoundingClientRect();
          if (rect.top >= 0 && rect.top < minTop) {
            minTop = rect.top;
            topHeading = heading;
          }
        });

        // If no heading is at or below the top, find the closest one above
        if (!topHeading) {
          minTop = Infinity;
          headings.forEach(heading => {
            const rect = heading.getBoundingClientRect();
            if (rect.top < 0 && Math.abs(rect.top) < Math.abs(minTop)) {
              minTop = rect.top;
              topHeading = heading;
            }
          });
        }

        if (topHeading) {
          const id = topHeading.id;
          const tocLink = document.querySelector(`a[href="#${id}"]`);
          if (tocLink && !tocLink.classList.contains("active")) {
            // Remove active from all links
            const activeLinks = document.querySelectorAll(".toc-link.active");
            activeLinks.forEach(link => {
              link.classList.remove("active");
            });
            // Add active to current link
            tocLink.classList.add("active");
          }
        }
      }, 100); // 100ms debounce

      // Function to handle scroll with requestAnimationFrame
      function handleScroll() {
        if (rafId) {
          cancelAnimationFrame(rafId);
        }
        rafId = requestAnimationFrame(updateActiveTocLink);
      }

      document.addEventListener("astro:page-load", function () {
        // Cleanup previous timer and raf
        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }
        if (rafId) {
          cancelAnimationFrame(rafId);
        }

        // Find all the links inside the TOC
        const tocLinks = document.querySelectorAll('a[href^="#"]');

        // Add click event listener to each TOC link
        tocLinks.forEach(link => {
          link.addEventListener("click", function (event) {
            event.preventDefault(); // Prevent default anchor behavior

            // Get the target element by the href attribute
            const targetId = this.getAttribute("href").substring(1);
            const targetElement = document.getElementById(targetId);

            // Scroll the target element into view, with the target in the center
            if (targetElement) {
              targetElement.scrollIntoView({
                behavior: "smooth",
                block: "center", // This ensures the target is in the center of the screen
              });
            }
          });
        });

        // Listen to scroll events with requestAnimationFrame
        window.addEventListener("scroll", handleScroll, { passive: true });
      });

      // Cleanup on page change
      document.addEventListener("astro:before-swap", function () {
        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }
        if (rafId) {
          cancelAnimationFrame(rafId);
        }
        window.removeEventListener("scroll", handleScroll);
      });
    </script>

  <!-- Blur Loading Script -->
  <script type="module">
      const initBlurLoading = () => {
        // Clear any existing observers to prevent duplicates
        if (window.blurLoadingObservers) {
          window.blurLoadingObservers.forEach(observer => observer.disconnect());
          window.blurLoadingObservers = [];
        }

        const lazyImages = document.querySelectorAll("img.img-loading");

        // Simple client-side concurrency queue to avoid N simultaneous Image() loads
        const MAX_CLIENT_CONCURRENT = 5;
        let clientActive = 0;
        const clientQueue = [];

        function scheduleLoad(fn) {
          return new Promise((resolve) => {
            const task = async () => {
              try {
                clientActive++;
                await fn();
              } finally {
                clientActive = Math.max(0, clientActive - 1);
                resolve();
                // kick next task from queue
                processNext();
              }
            };

            clientQueue.push(task);
            // start processing if slots are free
            processNext();
          });
        }

        function processNext() {
          if (clientQueue.length > 0 && clientActive < MAX_CLIENT_CONCURRENT) {
            const next = clientQueue.shift();
            if (next) {
              // Use setTimeout to avoid stack overflow and ensure proper async behavior
              setTimeout(() => next(), 0);
            }
          }
        }

        lazyImages.forEach(img => {
          // Skip if already processed
          if (img.dataset.blurProcessed) return;
          img.dataset.blurProcessed = 'true';

          const wrapper = img.closest('.blurry-load') || img.parentElement;
          // If no data-large provided, consider it already loaded
          if (!img.dataset.large) {
            img.classList.add('img-loaded');
            return;
          }

          const applyLoaded = () => {
            try { img.classList.add('img-loaded'); } catch(e){}
          };

          const applyFallback = () => {
            try {
              // As a last-resort, attempt to set the large src directly (with cache-bust)
              if (img.dataset.large && img.src !== img.dataset.large) {
                try {
                  const cb = `cb=${Date.now()}`;
                  const sep = img.dataset.large.includes('?') ? '&' : '?';
                  img.src = `${img.dataset.large}${sep}${cb}`;
                  console.warn('blurry-load: fallback swapped src directly to', img.dataset.large);
                } catch (e) {
                  console.warn('blurry-load: fallback direct swap failed', e);
                }
              }
            } catch (e) {}
            // remove blur visually by adding loaded class; optionally set placeholder
            applyLoaded();
          };

          const MAX_RETRIES = 2;
          const loadImage = () => {
            const big = new Image();
            let timedOut = false;
            const timeoutMs = 12000; // extend client-side timeout to 12s
            const timeout = setTimeout(() => {
              timedOut = true;
              const attempts = parseInt(img.dataset.blurAttempts || '0');
              console.warn('blurry-load: image load TIMEOUT for', img.dataset.large, 'attempts=', attempts + 1);
              if (attempts < MAX_RETRIES) {
                img.dataset.blurAttempts = String(attempts + 1);
                const backoff = 1000 * Math.pow(2, attempts);
                console.log('blurry-load: retrying after backoff', backoff, 'ms', 'for', img.dataset.large);
                setTimeout(() => {
                  loadImage();
                }, backoff);
                return;
              }
              console.warn('blurry-load: final timeout fallback for', img.dataset.large);
              applyFallback();
            }, timeoutMs);

            // Set decoding early (best-effort)
            try { big.decoding = 'async'; } catch (e) {}

            // Assign src first; then try to decode before swapping to avoid flicker
            big.src = img.dataset.large;

            const finishSwap = () => {
              if (timedOut) return;
              clearTimeout(timeout);
              // Only replace src if it's different to avoid unnecessary reflows
              if (img.src !== big.src) {
                try {
                  // Prefer using decode() when available so the browser has the image
                  // decoded before we assign into the visible <img>
                  if (typeof big.decode === 'function') {
                    big.decode().then(() => {
                      console.log('blurry-load: decoded, swapping src for', img.dataset.large);
                      img.src = big.src;
                      applyLoaded();
                    }).catch(() => {
                      // If decode fails, fallback to onload behaviour
                      console.warn('blurry-load: decode failed, swapping via onload fallback for', img.dataset.large);
                      img.src = big.src;
                      applyLoaded();
                    });
                  } else {
                    // Older browsers: swap on load event
                    console.log('blurry-load: swapping src via load fallback for', img.dataset.large);
                    img.src = big.src;
                    applyLoaded();
                  }
                } catch (e) {
                  console.error('blurry-load: unexpected error during swap', e, img.dataset.large);
                  img.src = big.src;
                  applyLoaded();
                }
              } else {
                applyLoaded();
              }
            };

            // If decode isn't available, rely on load event
            big.onload = finishSwap;
            big.onerror = () => {
              clearTimeout(timeout);
              const attempts = parseInt(img.dataset.blurAttempts || '0');
              console.warn('blurry-load: image error for', img.dataset.large, 'attempts=', attempts + 1);
              if (attempts < MAX_RETRIES) {
                img.dataset.blurAttempts = String(attempts + 1);
                const backoff = 1000 * Math.pow(2, attempts);
                console.log('blurry-load: retrying after error backoff', backoff, 'ms', 'for', img.dataset.large);
                setTimeout(() => {
                  loadImage();
                }, backoff);
                return;
              }
              console.warn('blurry-load: final error fallback for', img.dataset.large);
              applyFallback();
            };
          };

          // Check if image is already in viewport
          const isInViewport = (element) => {
            const rect = element.getBoundingClientRect();
            // Consider element in viewport if any part is visible (more permissive)
            const vh = window.innerHeight || document.documentElement.clientHeight;
            const vw = window.innerWidth || document.documentElement.clientWidth;
            return rect.bottom >= 0 && rect.top <= vh && rect.right >= 0 && rect.left <= vw;
          };

          if ('IntersectionObserver' in window) {
            // If already in viewport, schedule immediate load
            if (isInViewport(img)) {
              scheduleLoad(() => loadImage());
              return;
            }

            const io = new IntersectionObserver((entries, observer) => {
              entries.forEach(entry => {
                if (entry.isIntersecting) {
                  scheduleLoad(() => loadImage());
                  observer.unobserve(entry.target);
                }
              });
            }, { rootMargin: '200px' });

            io.observe(img);

            // Store observer for cleanup
            if (!window.blurLoadingObservers) window.blurLoadingObservers = [];
            window.blurLoadingObservers.push(io);
          } else {
            scheduleLoad(() => loadImage());
          }
        });
      };

      // Initial load
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        initBlurLoading();
      } else {
        document.addEventListener('DOMContentLoaded', initBlurLoading);
      }

      // Re-initialize on page navigation (Astro SPA-like routing)
      document.addEventListener('astro:page-load', () => {
        // Small delay to ensure DOM is fully updated
        setTimeout(initBlurLoading, 100);
      });
    </script>
  </body>
</html>

<style>
  html,
  body {
    margin: 0;
    width: 100%;
    height: 100%;
  }
</style>
