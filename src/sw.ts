/// <reference lib="webworker" />

// Type declarations for Service Worker environment
declare const self: ServiceWorkerGlobalScope;

interface SyncEvent extends ExtendableEvent {
  readonly tag: string;
}

declare global {
  interface Window {
    __WB_MANIFEST: any[];
  }
}

import { registerRoute } from "workbox-routing";
import {
  CacheFirst,
  NetworkFirst,
  StaleWhileRevalidate,
} from "workbox-strategies";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute } from "workbox-precaching";

// Precache all assets generated by Astro
precacheAndRoute(self.__WB_MANIFEST || []);

// Cache static assets with Cache First strategy
registerRoute(
  ({ request }) =>
    request.destination === "style" ||
    request.destination === "script" ||
    request.destination === "image" ||
    request.destination === "font",
  new CacheFirst({
    cacheName: "static-assets",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache pages with Network First strategy for fresh content
registerRoute(
  ({ request }) => request.destination === "document",
  new NetworkFirst({
    cacheName: "pages",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
  })
);

// Cache Notion images with specific strategy
registerRoute(
  ({ url }) =>
    url.hostname.includes("s3.amazonaws.com") ||
    url.hostname.includes("prod-files-secure"),
  new CacheFirst({
    cacheName: "notion-images",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 10, // 10 minutes - shorter than S3 URL expiration
      }),
    ],
  })
);

// Cache Google Fonts with Stale While Revalidate
registerRoute(
  ({ url }) =>
    url.origin === "https://fonts.googleapis.com" ||
    url.origin === "https://fonts.gstatic.com",
  new StaleWhileRevalidate({
    cacheName: "google-fonts",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Handle offline fallback
self.addEventListener("fetch", (event: FetchEvent) => {
  if (event.request.mode === "navigate") {
    event.respondWith(
      fetch(event.request).catch(async () => {
        const offlineResponse = await caches.match("/offline");
        if (offlineResponse) return offlineResponse;

        const notFoundResponse = await caches.match("/404");
        if (notFoundResponse) return notFoundResponse;

        return new Response("Offline page not found", { status: 404 });
      })
    );
  }
});

// Background sync for failed requests (if needed)
self.addEventListener("sync", (event: Event) => {
  const extendableEvent = event as ExtendableEvent;
  if ((extendableEvent as any).tag === "background-sync") {
    extendableEvent.waitUntil(doBackgroundSync());
  }
});

async function doBackgroundSync() {
  // Implement background sync logic here if needed
  console.log("Background sync triggered");
}

// Push notification handling (placeholder - not implemented per requirements)
self.addEventListener("push", (event: Event) => {
  // Push notifications not implemented per requirements
  console.log("Push received but not handled");
});

// Message handling for communication with main thread
self.addEventListener("message", (event: ExtendableMessageEvent) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

// Install event
self.addEventListener("install", (event: ExtendableEvent) => {
  console.log("Service Worker installing.");
  console.log("SW: Install event triggered, skipping waiting");
  self.skipWaiting();
});

// Activate event
self.addEventListener("activate", (event: ExtendableEvent) => {
  console.log("Service Worker activating.");
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          // Delete old caches that don't match current version
          if (
            cacheName !== "static-assets" &&
            cacheName !== "pages" &&
            cacheName !== "notion-images" &&
            cacheName !== "google-fonts"
          ) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  self.clients.claim();
});
