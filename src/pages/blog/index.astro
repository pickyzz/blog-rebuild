---
import Layout from "@/layouts/Layout.astro";
import Header from "@/components/Header.astro";
import Footer from "@/components/Footer.astro";
import Main from "@/layouts/Main.astro";
import Card from "@/components/Card.astro";
import Pagination from "@/components/Pagination.astro";
import SkeletonCard from "@/components/SkeletonCard.astro";

/* SSG mode - fetch from content collections */
export const prerender = true;

const { SITE } = await import("@/config");
const { getCollection } = await import("astro:content");
const posts = await getCollection("blog", ({ data }) => !data.draft);

// Sort posts by publication date (newest first)
const sortedPosts = posts.sort(
  (a, b) =>
    new Date(b.data.pubDatetime).valueOf() -
    new Date(a.data.pubDatetime).valueOf()
);

const pageSize = SITE.postPerPage || 10;
const page = {
  posts: sortedPosts.slice(0, pageSize),
  currentPage: 1,
  totalPages: Math.max(1, Math.ceil(sortedPosts.length / pageSize)),
  start: 1,
  end: Math.min(pageSize, sortedPosts.length),
  total: sortedPosts.length,
  size: pageSize,
  url: "/blog",
  prev: undefined,
  next: sortedPosts.length > pageSize ? "/blog/page/2" : undefined,
};

console.log(
  `[BLOG INDEX SSG] Loaded ${posts.length} posts from content collections`
);
console.log(`[BLOG INDEX SSG] Displaying ${page.posts.length} posts`);
---

<Layout title="Posts" canonicalURL="/blog">
  <Header />
  <Main pageTitle="Posts" pageDesc="All the articles I've posted.">
    {
      page.posts && page.posts.length > 0 ? (
        <>
          <ul id="post-container" class="mx-auto grid max-w-[80vw] grid-cols-1 gap-8 md:max-w-4xl md:grid-cols-2">
            {page.posts.map(post => (
              <Card href={`/blog/${post.slug}`} frontmatter={post.data} />
            ))}
          </ul>
          
          {/* Infinite Scroll Sentinel / Loading Indicator */}
          <div id="infinite-scroll-sentinel" class="mx-auto mt-8 grid max-w-[80vw] grid-cols-1 gap-8 opacity-0 transition-opacity duration-300 md:max-w-4xl md:grid-cols-2">
             <SkeletonCard />
             <SkeletonCard />
          </div>
        </>
      ) : (
        <p class="text-center">No posts available.</p>
      )
    }
  </Main>

  {/* Hidden Pagination (Required for Infinite Scroll Logic to scrape next URL) */}
  <div class="hidden">
    <Pagination {page} />
  </div>

  {/* End of Content Message */}
  <div id="end-of-content" class="mt-8 mb-12 hidden text-center text-sm text-muted-foreground opacity-70">
    — All posts loaded —
  </div>

  <Footer noMarginTop={page.totalPages > 1} />

  <script is:inline>
    // Infinite Scroll Implementation
    document.addEventListener("astro:page-load", () => {
      const container = document.getElementById("post-container");
      const sentinel = document.getElementById("infinite-scroll-sentinel");
      const endMessage = document.getElementById("end-of-content");
      
      if (!container || !sentinel) return;

      let nextUrl = null;
      let isLoading = false;
      const loadedUrls = new Set();
      
      // Function to update nextUrl from the current DOM
      const updateNextUrl = () => {
        const paginationNav = document.querySelector("nav[aria-label='Pagination']");
        if (paginationNav) {
            // Strictly look for the Next button using aria-label
            const nextLink = paginationNav.querySelector("a[aria-label='Next']");
            if (nextLink && !nextLink.classList.contains("disabled") && !nextLink.classList.contains("pointer-events-none") && nextLink.getAttribute("href")) {
                nextUrl = nextLink.getAttribute("href");
            } else {
                nextUrl = null;
            }
        }
      };

      // Initial check
      updateNextUrl();

      // If no next URL initially (e.g. only 1 page), hide sentinel and show end message
      if (!nextUrl) {
        sentinel.style.display = "none";
        if (endMessage) endMessage.classList.remove("hidden");
        return;
      }

      const observer = new IntersectionObserver(async (entries) => {
        if (entries[0].isIntersecting && nextUrl && !isLoading) {
          
          if (loadedUrls.has(nextUrl)) return;
          
          isLoading = true;
          sentinel.classList.remove("opacity-0"); // Show loader
          
          try {
            // Fetch next page
            const response = await fetch(nextUrl);
            const html = await response.text();
            
            // Parse result
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");
            const newPosts = doc.querySelectorAll("#post-container > *");
            
            // Append posts with duplicate check
            let appendedPosts = [];
            newPosts.forEach(post => {
              // Extract the link href to use as a unique key (e.g. /blog/slug)
              const link = post.querySelector("a")?.getAttribute("href");
              if (link) {
                  // Check if this link already exists in the current container
                  const exists = container.querySelector(`a[href="${link}"]`);
                  if (!exists) {
                      container.appendChild(post);
                      appendedPosts.push(post);
                  }
              } else {
                   // Fallback for non-link cards
                   container.appendChild(post);
                   appendedPosts.push(post);
              }
            });
            
            // If new posts were appended, wait for their images then reveal
            if (appendedPosts.length > 0) {
                 const imagePromises = appendedPosts.map(post => {
                     const img = post.querySelector("img");
                     if (!img) return Promise.resolve();
                     if (img.complete) return Promise.resolve();
                     return new Promise(resolve => {
                         img.onload = () => resolve();
                         img.onerror = () => resolve();
                     });
                 });
                 
                 // Wait for all images or timeout after 3s
                 const timeout = new Promise(resolve => setTimeout(resolve, 3000));
                 await Promise.race([Promise.all(imagePromises), timeout]);
                 
                 // Staggered Reveal
                 appendedPosts.forEach((post, index) => {
                     // Ensure opacity class is present (it should be from source, but just in case)
                     post.classList.add("opacity-0", "translate-y-8");
                     
                     setTimeout(() => {
                         post.classList.remove("opacity-0", "translate-y-8");
                     }, index * 100);
                 });
            }
            
            loadedUrls.add(nextUrl);

            // Update nextUrl from the fetched page's pagination
            const newPagination = doc.querySelector("nav[aria-label='Pagination']");
             if (newPagination) {
                const nextLink = newPagination.querySelector("a[aria-label='Next']");
                if (nextLink && !nextLink.classList.contains("disabled") && !nextLink.classList.contains("pointer-events-none") && nextLink.getAttribute("href")) {
                    nextUrl = nextLink.getAttribute("href");
                } else {
                    nextUrl = null;
                }
             } else {
                 nextUrl = null;
             }
             
             // If no posts were appended (all duplicates?), stop to prevent infinite loop of nothing
             if (appendedPosts.length === 0) {
                 nextUrl = null;
             }
             
          } catch (err) {
            console.error("Infinite scroll fetch error:", err);
            sentinel.innerText = "Error loading posts.";
          } finally {
             isLoading = false;
             sentinel.classList.add("opacity-0"); // Hide loader
             
             if (!nextUrl) {
                 observer.disconnect();
                 sentinel.style.display = "none";
                 if (endMessage) endMessage.classList.remove("hidden");
             }
          }
        }
      }, {
        rootMargin: "200px", // Preload before reaching bottom
      });

      observer.observe(sentinel);
    });
  </script>
</Layout>
