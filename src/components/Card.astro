---
import { slugifyStr } from "@/utils/slugify";
import Datetime from "./Datetime.astro";
import type { CollectionEntry } from "astro:content";

export interface Props {
  href?: string;
  frontmatter: any;
  secHeading?: boolean;
  priority?: "high" | "low";
}

const { href, frontmatter, secHeading = true, priority = "low" } = Astro.props;
const { title, pubDatetime, modDatetime, description, ogImage } = frontmatter;

// Use local image path or fallback to default
const imageSrc = ogImage || "/pickyzz-og.png";

const headerProps = {
  style: { viewTransitionName: slugifyStr(title) },
  class: "text-white text-[1.1rem] text-center text-lg font-medium",
};
---

<li class="card-wrapper group relative my-6 max-h-[350px] list-none opacity-0 translate-y-8 transition-all duration-700 ease-out">
  <a href={href} class="card-link">
    <!-- Image Container with Zoom Effect -->
    <div class="relative h-[13rem] w-full overflow-hidden">
      <img
        class="h-full w-full object-cover object-center transition-all duration-500 ease-out group-hover:scale-105 group-hover:brightness-110"
        src={imageSrc}
        loading="lazy"
        decoding="async"
        fetchpriority={priority}
        alt={title}
      />
      
      <!-- Gradient Overlay (Subtle) -->
      <div class="absolute inset-0 bg-gradient-to-t from-black/60 to-transparent opacity-60 transition-opacity duration-300 group-hover:opacity-40"></div>
      
      <!-- Glassmorphism Title Bar -->
      <div
        class="absolute bottom-0 left-0 right-0 flex min-h-[30%] items-center justify-center border-t border-white/10 bg-black/60 px-6 py-3 backdrop-blur-md transition-all duration-300 group-hover:bg-black/50"
      >
        {
          secHeading ? (
            <h2 {...headerProps}>{title}</h2>
          ) : (
            <h3 {...headerProps}>{title}</h3>
          )
        }
      </div>
    </div>

    <!-- Content / Meta -->
    <div class="card-content px-6 py-4">
      <p class="card-description mb-3 line-clamp-2 text-sm">
        {description}
      </p>
      <div class="card-datetime-wrapper flex items-center justify-center border-t border-dashed pt-3">
        <Datetime
          pubDatetime={pubDatetime}
          modDatetime={modDatetime}
          class="text-xs"
        />
      </div>
    </div>
  </a>
</li>

<style>
  /* Card styles using CSS variables for reliable theme switching */
  .card-link {
    display: block;
    height: 100%;
    overflow: hidden;
    border-radius: 1rem;
    background-color: var(--background);
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
    border: 1px solid var(--border);
    transition: all 0.3s ease;
  }
  
  .card-link:hover {
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    border-color: var(--accent);
  }
  
  .card-description {
    color: var(--foreground);
    opacity: 0.8;
  }
  
  .card-datetime-wrapper {
    border-color: var(--border);
  }
  
  /* Dark theme adjustments via data-theme attribute */
  :global(html[data-theme="dark"]) .card-link {
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
  }
  
  :global(html[data-theme="dark"]) .card-link:hover {
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
  }
</style>

<noscript>
    <style>
        .card-wrapper {
            opacity: 1 !important;
            transform: none !important;
        }
    </style>
</noscript>

<script>
  // Initial Load Animation for Cards
  document.addEventListener("astro:page-load", async () => {
    const cards = document.querySelectorAll(".card-wrapper.opacity-0");
    if (cards.length === 0) return;

    // Helper to wait for an image to load
    const contentLoaded = (card: Element) => {
        const img = card.querySelector("img");
        if (!img) return Promise.resolve();
        if (img.complete) return Promise.resolve();
        return new Promise((resolve) => {
            img.onload = () => resolve(true);
            img.onerror = () => resolve(true);
        });
    };

    // Wait for all images in the initial batch
    const promises = Array.from(cards).map(card => contentLoaded(card));
    
    // Optional: Promise.race with a timeout to prevent hanging forever if an image fails badly
    const timeout = new Promise(resolve => setTimeout(resolve, 3000));
    
    await Promise.race([Promise.all(promises), timeout]);

    // Staggered Reveal
    cards.forEach((card, index) => {
        setTimeout(() => {
            card.classList.remove("opacity-0", "translate-y-8");
        }, index * 100); // 100ms delay between each card
    });
  });
</script>
